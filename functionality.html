<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Functionality &#8212; HybMesh 0.5.1 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.5.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Grid Prototypes" href="prototypes.html" />
    <link rel="prev" title="Program Usage" href="usage.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="prototypes.html" title="Grid Prototypes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="usage.html" title="Program Usage"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">HybMesh 0.5.1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-hybmeshpack.hmscript"></span><div class="section" id="functionality">
<span id="id1"></span><h1>Functionality<a class="headerlink" href="#functionality" title="Permalink to this headline">¶</a></h1>
<div class="section" id="terminology">
<h2>Terminology<a class="headerlink" href="#terminology" title="Permalink to this headline">¶</a></h2>
<p>The program operates with four geometric object types: contour, 2d grid,
surface, 3d grid. All of these objects are described in a discretized form
by a set of vertices supplied with connectivity tables.
Each object has its own unique internal name which
is used for addressing.</p>
<p>Contour is a set of points connected in a defined order with each contour
section bearing a boundary type feature. Contour can be open or closed or
even multiply-connected (bounding a multiply connected domain).
Their direction could not be set implicitly.</p>
<p>2D grid is a set of cells which are defined as a sequences of edges.
Grid cell can have arbitrary number of vertices,
the only restriction applied to a grid cell is that it can not
be multiply connected.</p>
<p>Surface is a collection of faces which are given by edges list.
As well as with contours there are no restriction on the surface geometry.</p>
<p>3D grid is a set of 3D cells each of which is a closed surface.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Not every grid format supports arbitrary cells.
Most FEM grids (like those used in GMsh) could contain
only predefined (triangular or quadrangular for 2D) cell types.
This should be taken into account during grid exporting.</p>
</div>
<p>Each grid contains its own bounding contour which is
referenced as a grid contour or grid surface.
It includes all boundary nodes of the grid along with grid boundary features.
Most procedures which take contour/surface as an invariable input parameter (e.g.
set boundary types, exclude contour from a grid etc.), also accept
grid contours addressed by a grid internal name.</p>
<p>Boundary type is a non-geometric object which is defined
by integer positive boundary index (zero is the default value for non-defined
segments) and (optionally) a unique boundary name.
Grid exporting procedures try to use boundary names and indices
if export format supports it.</p>
</div>
<div class="section" id="data-access">
<h2>Data Access<a class="headerlink" href="#data-access" title="Permalink to this headline">¶</a></h2>
<p>Internal structure of geometric object could not be
explicitly changed by user. However readlonly access is possible.
HybMesh <a class="reference internal" href="pyinterface.html#pyinterf"><span class="std std-ref">sctipting interface</span></a> provides a set of <em>tab</em> functions
which return vertices coordinates and different connectivity tables as
plain 1D arrays by a given table name. See documentation of
<code class="xref py py-func docutils literal"><span class="pre">tab_cont2()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">tab_grid2()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">tab_surf3()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">tab_grid3()</span></code>
for details. In <a class="reference internal" href="oointerface.html#oointerfaces"><span class="std std-ref">wrapper interfaces</span></a>
some of those tables can be access via
<code class="xref py py-func docutils literal"><span class="pre">get_vertices</span></code>
and <code class="xref py py-func docutils literal"><span class="pre">get_tab</span></code> methods.
Note, that the latter function returns array of integers.
Hence only tables given by array of integers could be accessed.</p>
<p>An alternative way to read hybmesh geometry is to export it
to external file using supported format and parse it.
Currently export to ascii <em>VTK</em>, <em>Tecplot</em>, <em>Fluent mesh</em>, <em>GMsh</em>
formats is implemented. HybMesh also has its own
<a class="reference internal" href="fileformats.html#nativeformat"><span class="std std-ref">native data</span></a> format
which supports both binary and ascii data.
See <a class="reference internal" href="pyinterface.html#pyinterf-export"><span class="std std-ref">list</span></a> of script interface export functions
for details.</p>
</div>
<div class="section" id="grid-superposition">
<span id="gridimp"></span><h2>Grid Superposition<a class="headerlink" href="#grid-superposition" title="Permalink to this headline">¶</a></h2>
<p>This is the basic HybMesh operation. Generally it takes two independent
grids which have non-zero domain intersection and composes them into a single grid.
The domain of resulting grid is exactly equal to the domain of geometrical union of parent grid domains;
resulting cells reflect original grid everywhere except for a zone around the line of parent grids
contact, which is triangulated providing smooth cell size transition. This zone is later referenced as the
<em>buffer zone</em>.</p>
<p>Order of superposition matters. For clarity sake we call the first of two original grids the <em>base grid</em>
and the second one &#8211; the <em>overlaid grid</em>. <strong>Buffer is always built within the base grid</strong>. Cells
of <em>overlaid grid</em> are transfered to the resulting grid mostly untouched
(except for a few boundary vertices near grids intersection zone. See <a class="reference internal" href="#fixbnd"><span class="std std-ref">Fix boundary nodes</span></a> for details).
So, as you can see on the picture below, by swapping the grid roles we obtain different resulting grid geometry.</p>
<div class="figure" id="id5">
<a class="reference internal image-reference" href="_images/grid_imposition1.png"><img alt="_images/grid_imposition1.png" src="_images/grid_imposition1.png" style="height: 600px;" /></a>
<p class="caption"><span class="caption-text">fig. 1. Basic superposition example</span></p>
</div>
<p>Hybmesh also supports superposition of grids given as a chain.
In this regime a sequence of
superposition operations are performed over a list of grids. Each operation takes the result of previous one
as a <em>base grid</em> and use the next grid in given list as an <em>overlaid grid</em>.
You should carefully define the order of grids in a input list to get desirable result.
On a picture below you can see the superposition result depending on given grids order.</p>
<div class="figure" id="id6">
<a class="reference internal image-reference" href="_images/grid_imposition2.png"><img alt="_images/grid_imposition2.png" src="_images/grid_imposition2.png" style="height: 800px;" /></a>
<p class="caption"><span class="caption-text">fig. 2. Chain superposition example</span></p>
</div>
<p>Superposition with buffer grid building only takes place if parent grid has non-zero and non single point intersection area.
Operation results depending on relative position of input grids are presented below.</p>
<div class="figure" id="id7">
<a class="reference internal image-reference" href="_images/grid_imposition3.png"><img alt="_images/grid_imposition3.png" src="_images/grid_imposition3.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text">fig3. Superposition depending on types of given grid intersections.</span></p>
</div>
<p>If grid domains have no proper intersections (two last examples on the picture above)
then the resulting grid will contain cells from both given grids assembled into a
single connectivity table.
If grids have zero intersection but a common boundary segment (second example on the
picture above), a buffer will be built.
In such cases consider usage of <a class="reference internal" href="#snapgrid"><span class="std std-ref">snapping</span></a> function to snap
base grid to overlaid grid contour and guarantee exact connection of grid domains.</p>
<p>Boundary features of superposed grid contour reflect boundary features of given grids.
If both <em>base grid</em> and <em>overlaid grid</em> contain the same boundary segment, the
priority is given to features from the latter.</p>
<div class="section" id="buffer-zone-size">
<h3>Buffer zone size<a class="headerlink" href="#buffer-zone-size" title="Permalink to this headline">¶</a></h3>
<p>Buffer zone is constructed by those <em>base grid</em> cells which contain a vertex located
no further than the given buffer zone size from contact line. Larger buffer zone provides
smoother triangle grid within the buffer (see picture below).</p>
<div class="figure" id="id8">
<a class="reference internal image-reference" href="_images/grid_imposition4.png"><img alt="_images/grid_imposition4.png" src="_images/grid_imposition4.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text">fig4. Superposition with different buffer sizes</span></p>
</div>
<p>Sometimes it is useful to superpose grids without building triangulated buffer. This could be
done by setting zero buffer zone size.
However, if vertices of <em>base grid</em> and <em>overlaid grid</em> do not coincide at contact line superposed
grid will contain hanging nodes (see second example at picture below).
The necessity of superposing grids with zero buffer could be arisen e.g. while connecting grid to
an outer boundary grid built from its own contour.</p>
<div class="figure" id="id9">
<a class="reference internal image-reference" href="_images/grid_imposition5.png"><img alt="_images/grid_imposition5.png" src="_images/grid_imposition5.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text">fig5. Superposition with zero buffer size</span></p>
</div>
</div>
<div class="section" id="fix-boundary-nodes">
<span id="fixbnd"></span><h3>Fix boundary nodes<a class="headerlink" href="#fix-boundary-nodes" title="Permalink to this headline">¶</a></h3>
<p>This option defines treatment of <em>base grid</em> boundary vertices if they get into buffer zone.
Sometimes building a smooth grid within the buffer demands remeshing those boundaries. However
this can lead to change of the initial domain area and loss of some boundary features. Therefore
user is given a choice whether to allow algorithm to move such vertices or not.</p>
<p>If <em>fix boundary nodes</em> option is set to True then all boundary vertices presented in <em>base grid</em> and
<em>overlaid grid</em> will be present in the result grid if they lie on its domain boundary.
With this option is on it is guaranteed that:</p>
<ul class="simple">
<li><em>overlaid grid</em> is passed to result grid without any changes</li>
<li>shape of domain intersection of input grids is precisely preserved</li>
<li>boundary features of output grid exactly replicate input grid features</li>
</ul>
<p>However there are some possible drawbacks of this option.
Picture below illustrates superposition of two square grid with complicated boundary set.
First example shows the result of operation with fixed boundary vertices.
Due to the fact that points of intersection don&#8217;t hit any of the <em>overlaid grid</em>
initial vertices two hanging nodes have appeared in the result.
Furthermore since some of boundary nodes of <em>base grid</em> lied too close to
these intersection points highly skewed triangles were built in the buffer zone.</p>
<p>Second example on the picture below shows the same operation without <em>fix boundary nodes</em> option.
In order to get smoother grid two vertices of <em>overlaid grid</em> were moved to intersection locations and
buffer zone boundary segments were remeshed. As a result we&#8217;ve completely lost blue and magenta boundary
segments but the resulting grid don&#8217;t contain any hanging nodes or highly skewed cells.</p>
<div class="figure" id="id10">
<a class="reference internal image-reference" href="_images/grid_imposition7.png"><img alt="_images/grid_imposition7.png" src="_images/grid_imposition7.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-text">fig6. Superposition with and without fixing boundary nodes</span></p>
</div>
</div>
<div class="section" id="zero-angle-approximation">
<span id="zero-angle-app"></span><h3>Zero angle approximation<a class="headerlink" href="#zero-angle-approximation" title="Permalink to this headline">¶</a></h3>
<p>By default only boundary nodes which lie on a straight line (form an angle of 180 degree) could be moved when <em>fix boundary nodes</em> option
is off. This guaranties the exact preservation of domain intersection shape.
However if grids domain is formed by smooth curved lines the option <em>fix boundary nodes = False</em> will take no effect
since all points on such lines will be treated as corner points. Option <em>Zero angle approximation</em> (<img class="math" src="_images/math/e89765431934c995d7d6a5545dbd4dbf64122339.png" alt="\alpha_0"/>) allows user
to define which boundary polyline turns should be considered negligible and be treated as straight angles.
With non-zero <img class="math" src="_images/math/e89765431934c995d7d6a5545dbd4dbf64122339.png" alt="\alpha_0"/> all boundary vertices which lie within buffer zone and provide
turn between <img class="math" src="_images/math/cc9439fe974f3816da62e327925d41bd26cde572.png" alt="[180-\alpha_0, 180+\alpha_0]"/> will be considered as candidates for moving or removing.</p>
<p>The effect of <img class="math" src="_images/math/e89765431934c995d7d6a5545dbd4dbf64122339.png" alt="\alpha_0"/> option is shown in figure 7. Both results here were obtained with <em>fix boundary nodes = False</em>.
The first was done with <img class="math" src="_images/math/5b81b2dff25a1ba7bb6062c2d2eeb7f504b0d845.png" alt="\alpha_0=0"/> hence all arc points were preserved and very coarse cell size transition occurred in the
bottom of the buffer zone. In the second example arc boundary segment of the buffer zone was remeshed to get better grid quality. However
due to loss of some shape forming nodes in the latter case result domain doesn&#8217;t exactly equal
input grid intersection domain.</p>
<div class="figure" id="id11">
<a class="reference internal image-reference" href="_images/grid_imposition8.png"><img alt="_images/grid_imposition8.png" src="_images/grid_imposition8.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-text">fig7. Superposition without fixing boundary nodes and different
zero angle <img class="math" src="_images/math/d2b628db933181b0b8d929b971dc3f8ff255e94e.png" alt="{\alpha}_0"/> values</span></p>
</div>
</div>
<div class="section" id="empty-holes">
<span id="emptyholes"></span><h3>Empty holes<a class="headerlink" href="#empty-holes" title="Permalink to this headline">¶</a></h3>
<p>If this option of grid superposition is set to true then all hulls presented at <em>overlaid grid</em> will be
preserved as hulls in the result grid. Otherwise these hulls will be filled according to
general algorithm. The effect of this option is shown int picture below.</p>
<div class="figure" id="id12">
<a class="reference internal image-reference" href="_images/grid_imposition6.png"><img alt="_images/grid_imposition6.png" src="_images/grid_imposition6.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text">fig. 8. Superposition with/without <em>Empty holes</em> option</span></p>
</div>
</div>
<div class="section" id="buffer-fill">
<h3>Buffer fill<a class="headerlink" href="#buffer-fill" title="Permalink to this headline">¶</a></h3>
<p>By default buffer is filled by triangular cells. But if <em>buffer fill</em> option
is set to <em>&#8216;4&#8217;</em>  then a recombination algorithm will
be used to make a grid mostly quadrangular.
However even with this option a buffer may still contain few triangular cells
in areas where recombination failed.
The effect of this options is shown in picture below.</p>
<div class="figure" id="id13">
<a class="reference internal image-reference" href="_images/grid_imposition9.png"><img alt="_images/grid_imposition9.png" src="_images/grid_imposition9.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text">fig. 9. Superposition with buffer fill = &#8216;3&#8217; (default) and &#8216;4&#8217;</span></p>
</div>
<p>Python interface function: <code class="xref py py-func docutils literal"><span class="pre">unite_grids()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">unite_grids1()</span></code>.</p>
</div>
</div>
<div class="section" id="grid-snapping">
<span id="snapgrid"></span><h2>Grid Snapping<a class="headerlink" href="#grid-snapping" title="Permalink to this headline">¶</a></h2>
<p>This function is designed mostly to
be a preprocessor for <a class="reference internal" href="#gridimp"><span class="std std-ref">union</span></a> of grids
displaced side by side. However it also could be
used to adjust grid boundaries.</p>
<p>Consider situation depicted in the figure below.
Two grids are built in area bounded by a common contour but,
since they have different partition settings,
their boundaries do not match.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/snap_grid1.png"><img alt="_images/snap_grid1.png" src="_images/snap_grid1.png" style="width: 600px;" /></a>
</div>
<p>Direct superposition of those grids will result in a grid with
holes since those holes present in naïve geometrical sum of grid domains
(see the last picture in the figure above).
To fix that snapping function could be applied to tightly connect
base grid contour (blue one) to imposed grid contour (red one).</p>
<p>Only boundary grid vertices are altered with this procedure.
If these shifts result in a self-intersected grid
then an exception is raised.</p>
<div class="section" id="segments-definition">
<h3>Segments Definition<a class="headerlink" href="#segments-definition" title="Permalink to this headline">¶</a></h3>
<p>User should pass grid boundary and target contour segments
by definition of start and end points.
While detecting which point should be dubbed as <em>start</em>,
note that all closed contours have <strong>counterclockwise</strong> direction
regardless of their nesting level
(see how end points are marked in the picture above).</p>
<p>Grid boundary will be simply stretched to fit target segment.
Stretching is performed in such a way that <em>start</em>/<em>end</em> grid segment
points shift to the closest contour segment end point,
middle source segment point is moved to middle target segment
point and so on.</p>
<p>To mark the whole closed contour pass equal <em>start</em> and <em>end</em> points.</p>
</div>
<div class="section" id="algorithm">
<h3>Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this headline">¶</a></h3>
<p>Snapping <strong>algo</strong> option defines how grid boundary
vertex should be projected to target contour.
If given as <strong>add</strong> then its location
is computed directly by the stretching function.
If given as <strong>shift</strong> then it is
shifted from its computed position to the closest target
contour point.</p>
<p>Note, that this option regards only
internal grid segment points. End grid segment points will always be
shifted to respective end contour points.</p>
<p>The effect of this options is depicted in figure above.
As a general rule <em>algo=&#8217;add&#8217;</em> should be used if
given grid will be involved in superposition with non-zero buffer;
for zero buffer union <em>algo=&#8217;shift&#8217;</em> is preferred.</p>
<p>To prepare grid for superposition with zero buffer
in cases when number of edges in target and source segments does not match,
use <a class="reference internal" href="#heal-grid"><span class="std std-ref">Heal Grid</span></a> functionality with <em>convex_cells</em> option preceded by
<em>shift</em> snapping to adjust cells with hanging nodes. See the example below.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/snap_grid2.png"><img alt="_images/snap_grid2.png" src="_images/snap_grid2.png" style="width: 600px;" /></a>
</div>
<p>Python interface function: <code class="xref py py-func docutils literal"><span class="pre">snap_grid_to_contour()</span></code>.</p>
</div>
</div>
<div class="section" id="grid-contour-operations">
<h2>Grid-Contour Operations<a class="headerlink" href="#grid-contour-operations" title="Permalink to this headline">¶</a></h2>
<p>This set of operations modify existing grid geometry using domains or
polyline contours.</p>
<div class="section" id="inscribe-grid-into-domain">
<span id="inscribe-grid"></span><h3>Inscribe Grid into Domain<a class="headerlink" href="#inscribe-grid-into-domain" title="Permalink to this headline">¶</a></h3>
<p>Inscribe grid algorithm creates a new grid from given basic grid
and some multiply connected domain in such a way that all grid cells
lying outside (or inside) the domain are wiped out
and domain edges become
the new boundaries of created grid. In order to join domain edges and
grid cells some buffer zone is built and filled with unstructured mesh.
In fact this procedure acts almost like <a class="reference internal" href="#gridimp"><span class="std std-ref">Grid Superposition</span></a> algorithm but instead
of secondary grid a domain is used.</p>
<p>Grid can be inscribed either within or without the domain. In the
first case the resulting grid boundary will equal domain boundary with
corresponding boundary features. In the latter case resulting domain
is the geometrical difference of base grid area and domain area. And
boundary features will be taken from both sources with higher priority
of domain. The effect of both types of exclusion can be seen in the
figure below.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/inscribe_grid1.png"><img alt="_images/inscribe_grid1.png" src="_images/inscribe_grid1.png" style="width: 600px;" /></a>
</div>
<div class="section" id="resegmentation-options">
<span id="inscribe-domain-resegment"></span><h4>Resegmentation options<a class="headerlink" href="#resegmentation-options" title="Permalink to this headline">¶</a></h4>
<p>While filling the buffer the algorithm needs to use some 1D segmentation
of the domain. There is an option whether to use domain segmentation as it
is or rebuild it in a way best fitted to closest grid cell sizes.
In the figure above results obtained with keeping contour (upper row)
and rebuilding contour (lower row) are shown.</p>
<p>Resegmentation is performed using <em>zero angle</em> feature &#8211; a maximum deviation
from straight (180 degree) angle which is considered insignificant.
So all existing domain vertices
which provide a turn greater than <img class="math" src="_images/math/dab199ba906e140900be773594d008656d3a30f0.png" alt="180+\alpha_0"/>
or lower than <img class="math" src="_images/math/e6808c92d668757109a65c744588ce82f336bd65.png" alt="180-\alpha_0"/> will be kept after repartition.
<img class="math" src="_images/math/26d3f63d452026d8592d0bab569c02b174ac09aa.png" alt="\alpha_0=180"/> means that any vertex can be removed.
With <img class="math" src="_images/math/5b81b2dff25a1ba7bb6062c2d2eeb7f504b0d845.png" alt="\alpha_0=0"/> only vertices lying on the same line
can be removed or altered. A special value <img class="math" src="_images/math/af8d09b4cfb2ca2eeb0d9b836baad77186324ea1.png" alt="\alpha_0=-1"/> means
that all vertices should be kept (however new ones can still be added).</p>
<p>Note that even if <em>keep contour</em> option is set to true and
repartition of the domain is not performed, <em>zero angle</em> value
still matters while doing discretization of basic grid area sections
lying within the buffer.</p>
<p>Python interface function: <code class="xref py py-func docutils literal"><span class="pre">inscribe_grid()</span></code>.</p>
</div>
</div>
<div class="section" id="insert-line-and-site-constraints">
<span id="insert-constraints"></span><h3>Insert Line and Site Constraints<a class="headerlink" href="#insert-line-and-site-constraints" title="Permalink to this headline">¶</a></h3>
<p>This procedure inserts polylines and vertices into existing grid structure.
To connect embedded contours and points to grid cells, a buffer zone is
built and filled with unstructured mesh (see figure below).</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/insert_constraint1.png"><img alt="_images/insert_constraint1.png" src="_images/insert_constraint1.png" style="width: 600px;" /></a>
</div>
<p>Segmentation of embedded contours could be used as is or adopted with
respect to sizes of adjacent grid cells (see <em>keep contour</em> and <em>zero angle</em>
options in <a class="reference internal" href="#inscribe-domain-resegment"><span class="std std-ref">Resegmentation options</span></a>).
Unstructured grid step sizes near embedded vertices also
could be defined manually or calculated.</p>
<p>Passed contours could be open, closed and have intersections.
If <em>keep contour</em> is set to true (so resegmentation will not be done
while algorithm execution) cross points should present among
contour vertices.</p>
<p>Python interface function: <code class="xref py py-func docutils literal"><span class="pre">insert_grid_constraints()</span></code>.</p>
</div>
<div class="section" id="remove-cells">
<span id="id2"></span><h3>Remove Cells<a class="headerlink" href="#remove-cells" title="Permalink to this headline">¶</a></h3>
<p>This procedure removes all grid cells which satisfy the condition
with respect to a given multiply connected contour.
Exact type of condition is defined by the <strong>what</strong> argument.
Results obtained with different <strong>what</strong> options
are depicted in the figure below.
Note that all newly created boundary grid edges will have
default (zero) boundary feature. So boundary features of the substracted
area is not taking into account.</p>
<div class="figure" id="id14">
<a class="reference internal image-reference" href="_images/remove_cells1.png"><img alt="_images/remove_cells1.png" src="_images/remove_cells1.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">Remove Cells with different <strong>what</strong> option.</span></p>
</div>
<p>Python interface function: <code class="xref py py-func docutils literal"><span class="pre">remove_cells()</span></code>.</p>
</div>
<div class="section" id="substract-area">
<span id="id3"></span><h3>Substract Area<a class="headerlink" href="#substract-area" title="Permalink to this headline">¶</a></h3>
<p>Unlike the previous procedure this one makes an exact domain
exclusion applying clipping to those grid cells which cross excluded
area edges. The results of this procedure for both
inside and outside exclusion can be seen in the figure below.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/exclude_area1.png"><img alt="_images/exclude_area1.png" src="_images/exclude_area1.png" style="width: 500px;" /></a>
</div>
<p>All boundary edges of resulting grid are produced by either source grid
boundary or substracted area boundary. Hence boundary features of the
resulting grid are taken from input grid and contours. In case
of conflicts the priority is given to features of the substracted area.</p>
<p>Python interface function: <code class="xref py py-func docutils literal"><span class="pre">exclude_contours()</span></code>.</p>
</div>
</div>
<div class="section" id="unstructured-domain-meshing">
<span id="unstructured-meshing"></span><h2>Unstructured Domain Meshing<a class="headerlink" href="#unstructured-domain-meshing" title="Permalink to this headline">¶</a></h2>
<p>HybMesh can be used to build constrained triangulation
of any multiply connected domain using libgmsh algorithms.</p>
<p>Input domain and contour-type constraints should be
already discretized with desired segment lengths since
all input contours vertices will be present in the
resulting grid. Moreover boundary and constrain segment
lengths will be treated as internal cell size function sources
to provide smooth size transitions.
Use <a class="reference internal" href="#contmeshing"><span class="std std-ref">Contour 1D meshing</span></a> to obtain desired contour decomposition
and to control resulting cell sizes.</p>
<p>It is guaranteed that no grid edge will cross constraint contours.
Boundary types of the resulting grid will reflect boundary
types of input bounding domain.</p>
<p>The figure below presents results of constraint meshing of domains
with different segmentations:</p>
<div class="figure" id="id15">
<a class="reference internal image-reference" href="_images/domain_triangulation1.png"><img alt="_images/domain_triangulation1.png" src="_images/domain_triangulation1.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">fig. 1. Triangulation with contour constraints</span></p>
</div>
<p>Constraint contours could intersect one another and bounding contours.
However, to guarantee stability of program execution, points
of intersections should present in both intersected contours vertices list.
Use <a class="reference internal" href="#simplecontmeshing"><span class="std std-ref">Simple contour meshing</span></a> with <cite>crosses</cite> option or
<a class="reference internal" href="#matchedcontmeshing"><span class="std std-ref">Matched contour meshing</span></a> procedures to provide this.
An example of triangulation with crossed constraints is shown in figure below.</p>
<div class="figure" id="id16">
<a class="reference internal image-reference" href="_images/domain_triangulation2.png"><img alt="_images/domain_triangulation2.png" src="_images/domain_triangulation2.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">fig. 2. Crossed contour constraints.</span></p>
</div>
<p>As an additional instrument of internal cell size control
user can define a set of point-type constraints: geometrical point
with referenced adjacent cell size. All such
points will form grid nodes. See example below to see how this option works.</p>
<div class="figure" id="id17">
<a class="reference internal image-reference" href="_images/domain_triangulation3.png"><img alt="_images/domain_triangulation3.png" src="_images/domain_triangulation3.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">fig. 3. Point-type constraints.</span></p>
</div>
<p>Triangulation procedure could be followed by the recombination routine
which will try to transform the resulting grid cells to provide
mostly quadrangular grid. Use option <cite>fill = &#8216;4&#8217;</cite> to execute this
algorithm. All given constraints will still be actual.</p>
<div class="figure" id="id18">
<a class="reference internal image-reference" href="_images/domain_triangulation4.png"><img alt="_images/domain_triangulation4.png" src="_images/domain_triangulation4.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">fig. 4. Recombination algorithm effect.</span></p>
</div>
<p>It is also possible to build pebi-like finite volume grids
on the basis of triangulation procedure. Pebi grid building
procedure also accepts contour and point-type constraints.
Note, that in this case all
vertices presented in constraint contours and point-type
conditions will be located at the center of resulting grid cells.
Therefore boundary representation (but not domain area) of resulting grid
will be different from passed as a bounding domain contour.</p>
<p>This routine can produce concave cells (i.e. as a result of bad size
control or near the concave domain boundary vertices).
Use hybmesh <cite>heal grid</cite> routine with <code class="docutils literal"><span class="pre">convex_cells</span></code> option to fix this.
After the grid is built some optimization procedures will be executed
in order to get rid of short edges and possible self intersections.
So the resulting grid will not be strictly of pebi type.</p>
<div class="figure" id="id19">
<a class="reference internal image-reference" href="_images/domain_triangulation5.png"><img alt="_images/domain_triangulation5.png" src="_images/domain_triangulation5.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">fig. 5. Constrained pebi grid building.</span></p>
</div>
<p>Python interface function: <code class="xref py py-func docutils literal"><span class="pre">triangulate_domain()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">pebi_fill()</span></code></p>
<p>See also <a class="reference internal" href="intro_example6.html#example6"><span class="std std-ref">Example 6</span></a>.</p>
</div>
<div class="section" id="heal-grid">
<span id="id4"></span><h2>Heal Grid<a class="headerlink" href="#heal-grid" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
</div>
<div class="section" id="grid-mapping">
<span id="gridmappings"></span><h2>Grid Mapping<a class="headerlink" href="#grid-mapping" title="Permalink to this headline">¶</a></h2>
<p>This procedure maps the domain containing a grid (<em>base domain</em>) to any other domain with equal
connectivity (<em>target domain</em>) and uses this mapping to translate the grid.
Mapping is built as a result of solution of the Laplace&#8217;s equation with boundary conditions of
the first kind.
Boundary values are calculated using domains boundary mapping defined by user.
Boundary value problem is solved by a finite element method using
auxiliary triangular grid built within a solution domain.</p>
<p>There are no restrictions on the input grid and target domain except for their connectivity levels
should be equal and boundary mapping for each of bounding contours should
be provided.</p>
<p>Boundary features of resulting grid could be inherited either from <em>base</em> or from <em>target</em> domain
depending on user defined option.</p>
<div class="section" id="boundary-mapping-definition">
<h3>Boundary Mapping Definition<a class="headerlink" href="#boundary-mapping-definition" title="Permalink to this headline">¶</a></h3>
<p>Boundary mapping is defined by a collection of reference point pairs <img class="math" src="_images/math/2712d2ed56de2ddd150d8c33dd6fb6f8ceea607f.png" alt="(p_i, p'_i)"/> where
<img class="math" src="_images/math/24b68632b58b3294cc8f170cef67b2dd9510e981.png" alt="p_i"/> are points located on the <em>base domain</em> contour and <img class="math" src="_images/math/69f2444b4346d218a8fe7693954dd99cb83dd6dc.png" alt="p'_i"/> are points
from the <em>target domain</em> contour.
Any physical <em>base domain</em> point that equals
one of the defined <img class="math" src="_images/math/24b68632b58b3294cc8f170cef67b2dd9510e981.png" alt="p_i"/> will be mapped exactly to corresponding <img class="math" src="_images/math/69f2444b4346d218a8fe7693954dd99cb83dd6dc.png" alt="p'_i"/>,
otherwise linear interpolation between adjacent defined points will be made.</p>
<div class="figure" id="id20">
<a class="reference internal image-reference" href="_images/map_grid1.png"><img alt="_images/map_grid1.png" src="_images/map_grid1.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-text">fig.1. Grid mapping with different boundary mapping options</span></p>
</div>
<p>To obtain contour mapping user should define at least one reference point on it.
However to provide a good final result all characteristic contour points should be reflected
in the reference points collection.</p>
<p>Example of mapping of the uniform rectangle grid into a curvilinear
quadrangle is depicted in fig.1. If all four characteristic points are used for boundary mapping definition
(fig.1a) then all base contour corner points map into target contour corners and
all lateral sides of target contour have uniform partition (as it was in the base contour).</p>
<p>To obtain target boundary coarsening and refinement it is possible to define some additional
reference points on the laterals (fig.1b, fig.1c). However all such changes of boundary mapping
affect the area near the boundaries only. To get smooth internal grid with refinement towards
one of the edges base domain grid should be changed accordingly.</p>
<p>If not all corner points are defined in reference point set then this could lead to situations
when a corner point is mapped into a lateral segment.
If this happens resulting grid would have poor quality (fig.1d).</p>
<div class="figure" id="id21">
<a class="reference internal image-reference" href="_images/map_grid2.png"><img alt="_images/map_grid2.png" src="_images/map_grid2.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-text">fig.2. Mapping of doubly connected domain</span></p>
</div>
<p>In the figure above the example of mapping of a grid in the doubly connected domain is shown.
Since base grid has no corner points acceptable result could be obtained using single
reference point for each bounding contour (fig.2a), however definition of additional points in order
to adopt boundary points distribution increases grid quality (fig.2b).</p>
<p>The order of points in reference points set doesn&#8217;t matter. However this set should
be valid, i.e.:</p>
<ul class="simple">
<li>if points <img class="math" src="_images/math/aedadff181647c6a6e568dd41648abfcfc4a5061.png" alt="p_1, p_2"/> are located on the same base contour,
then corresponding points <img class="math" src="_images/math/c05637e8641c97eb79224d0f214136d2b4eee552.png" alt="p'_1, p'_2"/> should be located on
the same target contour;</li>
<li>if base contour points <img class="math" src="_images/math/aedadff181647c6a6e568dd41648abfcfc4a5061.png" alt="p_1, p_2"/> are located on the
same base contour and point <img class="math" src="_images/math/972dae29b8c99862e28bfeefd483fb941743e436.png" alt="p_3"/> lies between them
then point <img class="math" src="_images/math/43bd4bc75d72c25d32792d60e080ca37c0f99402.png" alt="p'_3"/> should lie between corresponding
points <img class="math" src="_images/math/c05637e8641c97eb79224d0f214136d2b4eee552.png" alt="p'_1, p'_2"/> on the target contour.</li>
</ul>
</div>
<div class="section" id="algorithms">
<span id="laplace-map-algo"></span><h3>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">¶</a></h3>
<div class="figure" id="id22">
<a class="reference internal image-reference" href="_images/map_grid3.png"><img alt="_images/map_grid3.png" src="_images/map_grid3.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">fig.3. Domain mapping</span></p>
</div>
<p>Let <img class="math" src="_images/math/cd30e0b91d2b53728ae09ccac9d857b79b3adfcb.png" alt="\Omega"/> and <img class="math" src="_images/math/4706192cb479bec00567b26489511b9bfbcf6621.png" alt="\Omega'"/> denote base and target domains
which are defined in two dimensional spaces <img class="math" src="_images/math/497184a5e83d0159a4bf15b0bb89dc5aa40cce7d.png" alt="(x,y)"/> and <img class="math" src="_images/math/fedb516446fee4723fd5f688c0b6d0c8e1781b46.png" alt="(\xi, \eta)"/> respectively (see fig.3).
To map a grid defined in <img class="math" src="_images/math/cd30e0b91d2b53728ae09ccac9d857b79b3adfcb.png" alt="\Omega"/> into the domain <img class="math" src="_images/math/4706192cb479bec00567b26489511b9bfbcf6621.png" alt="\Omega'"/> we have to build
continuous coordinate system transformation: <img class="math" src="_images/math/fbd322ce4f53623967567d365ac6b724a25f7c50.png" alt="(x,y)\to(\xi, \eta)"/> and apply it to all
grid vertices.</p>
<p>Hybmesh provides two methods of building such transformation. Both are based on a solution
of the Laplace equations system supplemented by boundary conditions of the first kind.
Problem formulation for the first one (later referenced as the <em>direct Laplace algorithm</em>) is
given in terms of functions <img class="math" src="_images/math/386621a28f5ed2c81c9f797ae18609c5d7a707db.png" alt="\xi(x, y)"/>, <img class="math" src="_images/math/01bd705e8084e06c24b4e7938b269c9572070a97.png" alt="\eta(x, y)"/> defined in the <em>base domain</em>:</p>
<div class="math" id="equation-direct_laplace">
<p><span class="eqno">(1)<a class="headerlink" href="#equation-direct_laplace" title="Permalink to this equation">¶</a></span><img src="_images/math/2716316010df46b88a9f9e6430705d6ebe056c74.png" alt="\begin{cases}
  -{\nabla^2}_{xy}\,\xi = 0, \\
  -{\nabla^2}_{xy}\,\eta = 0,
\end{cases}
\text{for } (x, y) \in \Omega;

\begin{cases}
  \xi = \xi_b(x, y),\\
  \eta = \eta_b(x, y),
\end{cases}
\text{for } (x, y) \in \gamma,"/></p>
</div><p>where <img class="math" src="_images/math/c4a59288843a7b763827db27756c22daf397d57f.png" alt="\xi_b"/>, <img class="math" src="_images/math/259fb730e38d0f37d1a4d28e316526c05bd5866e.png" alt="\eta_b"/> are known boundary mapping functions. After the solution of
<a class="reference internal" href="#equation-direct_laplace">(1)</a> is obtained further grid mapping is straightforward.</p>
<p>Second algorithm (later referenced as the <em>inverse Laplace algorithm</em>) is based on a formulation in terms of functions <img class="math" src="_images/math/b29197dffd2d0aa4ddc7a6b493519521a10a7599.png" alt="x(\xi, \eta)"/>,
<img class="math" src="_images/math/f8f98b15351ea36dc7aa80d453ad32cde32c2a02.png" alt="y(\xi, \eta)"/> defined in the <em>target domain</em>:</p>
<div class="math" id="equation-inverse_laplace">
<p><span class="eqno">(2)<a class="headerlink" href="#equation-inverse_laplace" title="Permalink to this equation">¶</a></span><img src="_images/math/dd45635efe32e596e25287eaa7557d4a1a34c5ed.png" alt="\begin{cases}
  -{\nabla^2}_{\xi\eta}\,x = 0, \\
  -{\nabla^2}_{\xi\eta}\,y = 0,
\end{cases}
\text{for } (\xi, \eta) \in \Omega';

\begin{cases}
  x = x_b(\xi, \eta),\\
  y = y_b(\xi, \eta),
\end{cases}
\text{for } (\xi, \eta) \in \gamma',"/></p>
</div><p>where <img class="math" src="_images/math/a6f5fc9a7deb89d39e3babe602e611b00d6457e2.png" alt="x_b"/>, <img class="math" src="_images/math/c6ccfb473f772c9c4f29c01d6cef486940db6f0a.png" alt="y_b"/> are known boundary mapping functions.
Functions <img class="math" src="_images/math/386621a28f5ed2c81c9f797ae18609c5d7a707db.png" alt="\xi(x, y)"/>, <img class="math" src="_images/math/01bd705e8084e06c24b4e7938b269c9572070a97.png" alt="\eta(x, y)"/> which are required for grid mapping
are obtained by inverting the functions <img class="math" src="_images/math/b29197dffd2d0aa4ddc7a6b493519521a10a7599.png" alt="x(\xi, \eta)"/>, <img class="math" src="_images/math/f8f98b15351ea36dc7aa80d453ad32cde32c2a02.png" alt="y(\xi, \eta)"/> gained
as a solution of the system <a class="reference internal" href="#equation-inverse_laplace">(2)</a>.</p>
<p><strong>These algorithms are not generic.</strong> To build a single valued transformation, functions
obtained as the solution of governing systems <a class="reference internal" href="#equation-direct_laplace">(1)</a> or <a class="reference internal" href="#equation-inverse_laplace">(2)</a>
should not contain local extrema and saddle points in the inner domain. The first property is provided by
the choice of governing equations however saddle points may occur for certain boundary
conditions. It is only guaranteed that</p>
<ul class="simple">
<li>transformation obtained by the <em>direct Laplace</em> algorithm is correct if
<em>target domain</em> is convex;</li>
<li>transformation obtained by the <em>inverse Laplace</em> algorithm is correct if
<em>base domain</em> is convex.</li>
</ul>
<p>Violation of the above conditions doesn&#8217;t inevitably lead to incorrect mappings.
Ambiguous transformations occur only near the &#8220;sharply concave&#8221; domain edges.
Furthermore, even if such transformation was obtained but all grid points stay
outside ambiguous zones, then the result will still be fine.</p>
<div class="figure" id="id23">
<a class="reference internal image-reference" href="_images/map_grid4.png"><img alt="_images/map_grid4.png" src="_images/map_grid4.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-text">fig.4. Mapping to and from a concave domain</span></p>
</div>
<p>For example let us consider mapping of the uniform rectangle grid
into a domain with M-shaped top side (see fig.4).
Since the <em>base domain</em> is convex we can securely do it using the <em>inverse Laplace</em> method (fig.4b);
the <em>direct Laplace</em> algorithm gives improper mapping and self-intersected grid as it is
shown in fig.4a.
If we swap the roles of <em>base</em> and <em>target</em> domains, i.e. try to map
M-shaped grid into a rectangle, then, on the contrary, only the <em>direct Laplace algorithm</em>
will provide a single-valued transformation (fig.4c). The <em>inverse</em> method gives improper
mapping, i.e. some points of the <em>target domain</em> are mapped outside the <em>base domain</em>,
however, as soon as all inner base grid points have single-valued images at <em>target domain</em>,
the program is able to assemble valid, although not qualitative grid (fig.4d).</p>
<p>The proper method for grid mapping depends on a shape of input domains.
Since in practical applications <em>base domains</em> are often chosen to be smooth and regular
then the <em>inverse Laplace</em> algorithm seems to be more robust, however in some cases the <em>direct method</em>
provides better mapping near the boundaries (see examples in fig.4c, fig.5).</p>
<div class="figure" id="id24">
<a class="reference internal image-reference" href="_images/map_grid5.png"><img alt="_images/map_grid5.png" src="_images/map_grid5.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">fig.5. Comparison of <em>direct</em> and <em>inverse</em> algorithms applied to
a doubly connected domain</span></p>
</div>
</div>
<div class="section" id="snapping">
<h3>Snapping<a class="headerlink" href="#snapping" title="Permalink to this headline">¶</a></h3>
<p>The domain of a grid obtained by mapping procedure will not exactly equal the target domain
until boundary mapping for each valuable  <em>target domain</em> vertex is explicitly defined (see fig.6a).
However the program can evolute a special postprocessing procedure which modifies
resulting boundary vertices with respect to original <em>target contour</em>.</p>
<div class="figure" id="id25">
<a class="reference internal image-reference" href="_images/map_grid6.png"><img alt="_images/map_grid6.png" src="_images/map_grid6.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text">fig.6. Grid map with snapping. Magenta markers denote <em>target domain</em> vertices.</span></p>
</div>
<p>With the snapping option <em>&#8220;Shift vertices&#8221;</em> all boundary vertices of resulting grid will be
shifted to closest valuable <em>target</em> vertex (see fig.6b). Option <em>&#8220;Add vertices&#8221;</em> forces
all boundary edges be extended by <em>target</em> vertices which lie between edge end points ( see fig.6c).
The latter guarantees that the resulting domain will be equal to the original <em>target domain</em>, however
it changes grid topology so that it won&#8217;t be the same as the topology of the <em>base grid</em>.</p>
<p>Snapping for each boundary edge will only take place if it is valid, i.e. it
will not result in intersections with internal grid edges.</p>
<p>Python interface function: <code class="xref py py-func docutils literal"><span class="pre">map_grid()</span></code>.
See also: <a class="reference internal" href="prototypes.html#custom-rect-grid"><span class="std std-ref">Custom Rectangle Grid</span></a>, <a class="reference internal" href="prototypes.html#circrect-grid"><span class="std std-ref">Square in Circle</span></a>.</p>
</div>
</div>
<div class="section" id="contour-operations">
<h2>Contour Operations<a class="headerlink" href="#contour-operations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="contour-1d-meshing">
<span id="contmeshing"></span><h3>Contour 1D meshing<a class="headerlink" href="#contour-1d-meshing" title="Permalink to this headline">¶</a></h3>
<div class="section" id="simple-contour-meshing">
<span id="simplecontmeshing"></span><h4>Simple contour meshing<a class="headerlink" href="#simple-contour-meshing" title="Permalink to this headline">¶</a></h4>
<p>The most simple way to perform contour 1D meshing is to
define desired step and pass it along with the contour to hybmesh.
If input contour is smooth enough then equidistant meshing will be done.
Sometimes it is necessary to define some refinement to contour discretization.
This could be done by setting reference points conditions. Reference points
should lie on the contour. They act as a size function source to their left and right side
along the contour until another reference point or contour end.
These points will not be a part of resulting segmentation. Results of
contour meshing with different conditions could be seen below.</p>
<div class="figure" id="id26">
<a class="reference internal image-reference" href="_images/cont_meshing1.png"><img alt="_images/cont_meshing1.png" src="_images/cont_meshing1.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">fig. 1. Contour meshing with constant step and reference points options.</span></p>
</div>
<p>User can also define a desired number of resulting contour segments.
If that was done then for constant step method given step plays no role at all.
If reference point method was applied then refinement given through these points
will be preserved but scaled in order to match fixed segment number condition.</p>
<div class="figure" id="id27">
<a class="reference internal image-reference" href="_images/cont_meshing2.png"><img alt="_images/cont_meshing2.png" src="_images/cont_meshing2.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">fig. 2. Contour meshing with fixed segments number, relative refinement.</span></p>
</div>
<p>Sometimes contour contains points which must be kept in a 1D discretization.
This procedure provides four mechanisms of keeping such points:</p>
<ul class="simple">
<li>explicit definition of such points;</li>
<li>definition of <img class="math" src="_images/math/e89765431934c995d7d6a5545dbd4dbf64122339.png" alt="\alpha_0"/> tells program to keep all input contour vertices
which provide turns outside of <img class="math" src="_images/math/a2190f7559d631c24364e3e3ef73b482ae32c184.png" alt="[180 - \alpha_0, 180 + \alpha_0]"/> degrees range.
So by setting <img class="math" src="_images/math/955a9b5e29143fbe500a9750490cc6abeb1a0cc0.png" alt="\alpha_0 = 0"/> algorithm will keep all original target contour vertices
except those lying on the straight line
and <img class="math" src="_images/math/26d3f63d452026d8592d0bab569c02b174ac09aa.png" alt="\alpha_0=180"/> will disable that option. If <img class="math" src="_images/math/4eb5e2f226ee61ff9990c54d122d3304c6926115.png" alt="\alpha_0 = -1"/> then
all original vertices will be preserved;</li>
<li>with option <strong>keep boundary = True</strong> algorithm will not throw away original vertices
which provide boundary contour types changes;</li>
<li>along with target contour user can define a set of other contours with <strong>crosses</strong>
option. Algorithm will calculate all intersection points between them and the original
contour and put all those points into resulting segmentation.</li>
</ul>
<div class="figure" id="id28">
<a class="reference internal image-reference" href="_images/cont_meshing3.png"><img alt="_images/cont_meshing3.png" src="_images/cont_meshing3.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-text">fig. 3. Contour meshing with different <img class="math" src="_images/math/e89765431934c995d7d6a5545dbd4dbf64122339.png" alt="\alpha_0"/>, meshing with cross contour given.</span></p>
</div>
<p>Python interface function: <code class="xref py py-func docutils literal"><span class="pre">partition_contour()</span></code>.</p>
</div>
<div class="section" id="matched-contour-meshing">
<span id="matchedcontmeshing"></span><h4>Matched contour meshing<a class="headerlink" href="#matched-contour-meshing" title="Permalink to this headline">¶</a></h4>
<div class="figure" id="id29">
<a class="reference internal image-reference" href="_images/cont_meshing4.png"><img alt="_images/cont_meshing4.png" src="_images/cont_meshing4.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text">fig. 4. Matched contour meshing with reference point and contour condition</span></p>
</div>
<p>As the previous contour meshing algorithm, matched meshing
provides routine to build 1D grid using given size function conditions.
In simple meshing method those conditions were defined on the contour and act along the contour line only.
Here conditions work in a 2D area with given <strong>influence radius</strong> and <strong>power</strong>.
As a size function source a set of standalone points
with referenced sizes or another contours could be used.
In the latter case conditional contour partition by itself is
treated as a size source.</p>
<p>To apply this method user has to define constant <strong>step size</strong>, which
will be used in areas where no conditions are acting and as a
term to define weighted size in areas under the influence of conditions.
User also defines a <strong>zero angle</strong> to tell algorithm to keep corner points.
The default value is 30 degrees.
If conditional contour intersects target contour, then intersection point
will be calculated and preserved in the resulting mesh.</p>
<p>This procedure could be useful for building 1D meshes prior to
<a class="reference internal" href="#unstructured-meshing"><span class="std std-ref">unstructured constraint triangulation</span></a> of areas.
See example of usage in <a class="reference internal" href="intro_example6.html#example6"><span class="std std-ref">Example 6</span></a>.</p>
<p>Python interface function: <code class="xref py py-func docutils literal"><span class="pre">matched_partition()</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="d-grid-building">
<h2>3D Grid Building<a class="headerlink" href="#d-grid-building" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Functionality</a><ul>
<li><a class="reference internal" href="#terminology">Terminology</a></li>
<li><a class="reference internal" href="#data-access">Data Access</a></li>
<li><a class="reference internal" href="#grid-superposition">Grid Superposition</a><ul>
<li><a class="reference internal" href="#buffer-zone-size">Buffer zone size</a></li>
<li><a class="reference internal" href="#fix-boundary-nodes">Fix boundary nodes</a></li>
<li><a class="reference internal" href="#zero-angle-approximation">Zero angle approximation</a></li>
<li><a class="reference internal" href="#empty-holes">Empty holes</a></li>
<li><a class="reference internal" href="#buffer-fill">Buffer fill</a></li>
</ul>
</li>
<li><a class="reference internal" href="#grid-snapping">Grid Snapping</a><ul>
<li><a class="reference internal" href="#segments-definition">Segments Definition</a></li>
<li><a class="reference internal" href="#algorithm">Algorithm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#grid-contour-operations">Grid-Contour Operations</a><ul>
<li><a class="reference internal" href="#inscribe-grid-into-domain">Inscribe Grid into Domain</a><ul>
<li><a class="reference internal" href="#resegmentation-options">Resegmentation options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#insert-line-and-site-constraints">Insert Line and Site Constraints</a></li>
<li><a class="reference internal" href="#remove-cells">Remove Cells</a></li>
<li><a class="reference internal" href="#substract-area">Substract Area</a></li>
</ul>
</li>
<li><a class="reference internal" href="#unstructured-domain-meshing">Unstructured Domain Meshing</a></li>
<li><a class="reference internal" href="#heal-grid">Heal Grid</a></li>
<li><a class="reference internal" href="#grid-mapping">Grid Mapping</a><ul>
<li><a class="reference internal" href="#boundary-mapping-definition">Boundary Mapping Definition</a></li>
<li><a class="reference internal" href="#algorithms">Algorithms</a></li>
<li><a class="reference internal" href="#snapping">Snapping</a></li>
</ul>
</li>
<li><a class="reference internal" href="#contour-operations">Contour Operations</a><ul>
<li><a class="reference internal" href="#contour-1d-meshing">Contour 1D meshing</a><ul>
<li><a class="reference internal" href="#simple-contour-meshing">Simple contour meshing</a></li>
<li><a class="reference internal" href="#matched-contour-meshing">Matched contour meshing</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#d-grid-building">3D Grid Building</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="usage.html"
                        title="previous chapter">Program Usage</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="prototypes.html"
                        title="next chapter">Grid Prototypes</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/functionality.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="prototypes.html" title="Grid Prototypes"
             >next</a> |</li>
        <li class="right" >
          <a href="usage.html" title="Program Usage"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">HybMesh 0.5.1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, KalininEI.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
  </body>
</html>